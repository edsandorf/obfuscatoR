---
title: "An introduction to the obfuscatoR package"
author:
  - Erlend Dancke Sandorf^[University of Stirling, Stirling Management School, Economics Division, e.d.sandorf@stir.ac.uk]
  - Caspar Chorus^[Delft University of Technology, Department of Engineering Systems and Services]
  - Sander van Cranenburgh^[Delft University of Technology, Department of Engineering Systems and Services]
package: obfuscatoR
abstract: >
  Chorus et al. (2019) puts forward the idea that sometimes when people make choices  they wish to hide their true motivation from a potential onlooker. The obfuscatoR  package allows researchers to easily create and customize "obfuscation" games to test  the obfuscation hypothesis.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette-obfuscatoR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

If you have not already installed the package, the newest version is available from GitHub.

```{r, eval = FALSE}
devtools::install_github('edsandorf/obfuscatoR')
```

Once you have installed the package, go ahead and load it using the standard library function in R. 

```{r setup}
library(obfuscatoR)
```

This vignette sets out to describe how to use the package to generate simple and more complex versions of the obfuscation game. Once we have grasped the simple mechanics of the package, we will show you how to introduce additional restrictions that are useful to raise or lower the difficulty of the game for both decision makers and observers. 
  
## Generating a simple design {#simple-design}
First, let us create a very simple design. At a minimum, we need to specify the number of possible rules and actions. We specify this in a list of design options `design_opt_input` as follows (click [here](#design-options) for a full list of options): 

```{r}
design_opt_input <- list(rules = 4,
                         actions = 5)
```

Above, we specified that our design consists of 4 possible rules governing a decision maker's actions, and that there are 5 possible actions that he can take. To create a design, we pass the list of design options to the `generate_designs()` function.

```{r}
design <- generate_designs(design_opt_input)
```

Our design is a matrix with rows equal to the number of rules and columns equal to the number of possible actions. Throughout, the design will also be referred to as a rules-action matrix. We can print generated rules and action matrix using the `print_design()` function. 

```{r}
print_design(design)
```

Notice that this game is generated conditional on rule number 2 governing the decision maker's actions. The rule is selected as part of the design generation process, and cannot be set by the analyst. It is possible to print additional information about the design generation process by setting `print_all = TRUE`. This will provide information on the number of iterations and whether all design conditions were met. 

```{r}
print_design(design, print_all = TRUE)
```

Note: It is possible to extract the vector of design conditions with `extract_attr(design, "design_conditions")`. 

### Controlling replicability {#set-seed}
The default behavior of the obfuscatoR package is to set a random seed each time you generate a design. This is to minimize the possibility of always generating the same designs. However, sometimes it may be required to generate the same design, e.g. to ensure replicability or for teaching purposes. It is possible to set the seed for the random number generator using the `seed` option. For example: `design_opt_input <- list(seed = 10)`. Here, we have set the initial seed to 10. If we are generating [multiple designs](#multiple-designs), then the seed will increment by 1 for each design. That is, if the initial seed is 10 and we generate two designs, then the first design will be generated with seed set to 10 and the second with seed set to 11.

## Calculate the entropy of each action

The obfuscatoR package also includes a set of functions to evaluate the designs and calculate the entropy of a design. To identify the action that would leave the observer as clueless as possible as to which rule governs the decision maker's choice, we need to calculate the entropy of each action. We can do this using the `calculate_entropy()` function. 

```{r}
entropy <- calculate_entropy(design)
```

An obfuscating decision maker will choose an action, conditional on his rule, that will leave the observer as clueless as possible, i.e. with the highest entropy. We can print the the results of the entropy calculation using the `print_entropy()` function. 

```{r}
print_entropy(entropy)
```

To calculate the entropy of the action we also need to calculate the probability of an action conditional on a rule and the probability of a rule conditional on an action. We can print the results of these calculations by setting `print_all = TRUE`.

```{r}
print_entropy(entropy, print_all = TRUE)
```

### Supplying a vector of prior probabilities

It is possible to supply a vector of prior probabilities when calculating the entropy measure. If no vector of priors are supplied, we assume flat priors, i.e. $1/R$, where $R$ is the number of rules. 

```{r}
prior_probs <- c(0.2, 0.3, 0.15, 0.35)
entropy <- calculate_entropy(design, priors = prior_probs)
print_entropy(entropy, print_all = TRUE)
```

## Restrictions in the design 

To make what we consider valid designs, we have implemented a set of restrictions, some of which can be changed by the user. This list is ordered to match the output vector from: `extract_attr(design, "design_conditions")`.

1. The considered rule cannot have an obligated action. If it did, then the decision maker would only have one choice and the observer would be able to guess the rule with a high degree of accuracy. 
2. No action can be forbidden by every rule.
3. Allowable actions has to fit a minimum number of rules (see below)
4. No two actions can be identical.
5. The entropy maximizing action must be permitted by the considered rule
6. The entropy maximizing action must have the lowest posterior probability
7. Ensure a certain spread of the entropy measures (see below)
8. We can only have one entropy maximizing action.


# More complex designs {#complex-designs}

The designs outlined above are fairly simple. We have placed no restrictions on the design with respect to the number of rules that are allowed nor have we included rules with obligatory actions. The obfuscatoR package includes several options that allow us to create designs that vary with respect to the maximum and minimum allowable actions per rule, the number of rules with obligatory actions and even ensure a given spread of the entropy among the actions available to decision makers. Let us take a closer look at the various options that are available to us. 

## Introducing obligatory actions {#obligatory-actions}

We can specify the number of obligatory actions through the use of the option `obligatory`. Let us continue to work with the design from above, but this time we will specify that one of the rules has an obligatory action.

```{r}
design_opt_input <- list(rules = 4,
                         actions = 5,
                         obligatory = 1)

design <- generate_designs(design_opt_input)

print_design(design, FALSE)
```

The rule with an obligatory action is the row with only -1 and 1 in the matrix above. 

## Setting minimum and maximum number of available actions for the considered rule {#min-max}

As the size of our designs become larger, in order to keep the complexity of the choice at a reasonable level, we might want to specify a minimum and maximum number of allowed actions under the considered rule. We can easily do this through the options `min` and `max`. 

```{r}
design_opt_input <- list(rules = 4,
                         actions = 5,
                         min = 2, 
                         max = 3,
                         obligatory = 1)

design <- generate_designs(design_opt_input)

print_design(design, FALSE)
```

## Setting a minimum number of rules for each permitted action {#min-fit}

Sometimes it will be desirable to exclude certain rules, for example, we may wish to specify a minimum number of rules fitting each permitted action conditional on the considered rule. This is slightly different to the specification above. Essentially, this option will increase the difficulty for the observer. Using the `min_fit` option, we can specify the minimum number of rules. 

```{r}
design_opt_input <- list(rules = 4,
                         actions = 5,
                         min_fit = 2,
                         obligatory = 1)

design <- generate_designs(design_opt_input)

print_design(design, FALSE)
```

## Ensuring spread of entropy {#spread-entropy}

Given the trial and error nature of searching for obfuscation designs, by chance, we may end up in a situation where the difference between the entropy maximizing action and the second best is very small. This will make it very difficult for both decision makers and observers to identify the entropy maximizing action. The `generate_designs()` function includes an option that allow us to specify the "spread" of entropy. 

```{r}
design_opt_input <- list(rules = 4,
                         actions = 5,
                         considered_rule = 3,
                         sd_entropy = 0.15)

design <- generate_designs(design_opt_input)

print_design(design, FALSE)
```

Compared to the designs above, we see that we have a much larger spread of entropy for each action.

```{r}
entropy <- calculate_entropy(design)

print_entropy(entropy)
```

## Creating multiple designs {#multiple-designs}

Above, we have focused on one shot games, i.e. we have generated a single design. Often, researchers may want to play repeated games. The obfuscatoR package makes it easy to create multiple designs. Let us create a series of 2 designs by setting `designs = 2`. We are only using 2 designs here to save space when printing the output.

```{r}
design_opt_input <- list(rules = 4,
                         actions = 5,
                         considered_rule = 3,
                         designs = 2)

design <- generate_designs(design_opt_input)

print_design(design, TRUE)
```

To calculate the entropy associated with each action in the designs, we can run the calculate entropy function, but this time we supply a list of designs. 

```{r}
entropy <- calculate_entropy(design)

print_entropy(entropy)
```
If you wish to print all the information about all designs, as above, you can set `print_all = TRUE` as shown below. We leave the user to run that code on their own machine given the rather large output. 

```{r, eval = FALSE}
print_entropy(entropy, print_all = TRUE)
```

## The full list of design_options {#design-options}

| Option | Description | Default | Must be specified |
|--------|-------------|---------| ------------------|
| [rules](#simple-design)  | The number of rules | NULL | Yes |
| [actions](#simple-design) | The number of actions | NULL | Yes |
| [min](#min-max) | Minimum number of actions available for the considered rule | NA | No |
| [max](#min-max) | Maximum number of actions available for the considered rule | NA | No |
| [min_fit](#min-fit) | Minimum number of rules fitting each permitted action conditional on the rule | 0 | No |
| [obligatory](#obligatory-actions) | Number of rules with obligatory actions | 0 | No |
| [sd_entropy](#spread-entropy) | Specifies the standard deviation of the entropy values | NA | No |
| [designs](#multiple-designs) | Number of designs to generate | 1 | No |
| max_iter | Maximum number of iterations before stopping the search for designs | 1e5 | No |
| [seed](#set-seed) | A seed for the random number generator | NA | No |

## A cautionary note

The search for new designs is one of trial and error. If you set too many or too tight restrictions on your designs, you may not be able to find valid designs in a reasonable time and the search algorithm will continue until it is stopped. 

It is good practice to manually inspect all designs prior to use to ensure that they are indeed of the form you want. 

# Saving the designs {#saving}

Once you have created your designs, you might want to save them. We can do this using the `save_design()` function. The function stores the designs in a .csv file or multiple .csv files if you have generated multiple designs. The function will automatically generate a name of the form "FILE-NAME-rule-X-design-I.csv", where **X** is the considered rule used to generate the design, and **I** is the design number.

```{r, eval = FALSE}
save_design(design, "my_designs")
```

# Calculating the payouts {#payout}

We can calculate the payouts to the decision makers and observers using the `calculate_payouts` function. The expected payout to the observer from trying to guess the rule conditional on observing an action, is the payout weighted by the highest posterior probability for each action. The expected payout to the decision maker, on the other hand, depends on the probability that the observer will guess. As such it is the payout to the decision maker weighted by the probability that the observer will try and guess the rule. 

```{r}
design_opt_input <- list(rules = 4,
                         actions = 5)

design <- generate_designs(design_opt_input)
entropy <- calculate_entropy(design)

payout <- calculate_payouts(entropy,
                            pay_obs = 10,
                            pay_no_guess = 5,
                            pay_dm = 5,
                            deterministic = FALSE)
```


```{r}
print_payout(payout, print_all = TRUE)
```
